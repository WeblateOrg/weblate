# Copilot Instructions for Weblate

Weblate is a libre software web-based continuous localization system used by over 2500 libre projects and companies in more than 165 countries. This document provides guidelines for GitHub Copilot when working on the Weblate codebase.

## Project Overview

- **Technology Stack**: Django 5.1+, Python 3.12+, JavaScript, HTML/CSS
- **Purpose**: Web-based translation management platform with VCS integration
- **Architecture**: Django web application with Celery background tasks
- **Database**: PostgreSQL, MySQL, MariaDB support
- **Frontend**: Bootstrap-based UI with JavaScript enhancements

## Code Style and Standards

### Python Code
- Follow PEP 8 standards
- Use Django best practices and conventions
- Type hints are encouraged (project uses `py.typed`)
- Use `gettext_lazy` for translatable strings
- Import Django components following Django conventions
- Use class-based views where appropriate

### Frontend Code
- Use Bootstrap 4/5 classes for styling
- Follow existing JavaScript patterns in the codebase
- Use jQuery for DOM manipulation (existing pattern)
- Maintain accessibility standards

### Templates
- Use Django template syntax with proper escaping
- Follow existing template structure and patterns
- Use `{% translate %}` and `{% blocktranslate %}` for i18n
- Maintain semantic HTML structure

## Development Workflow

### Testing
- Use pytest with Django integration (`pytest-django`)
- Test files are located in `*/tests/` directories
- Run tests with: `python manage.py test`
- Write unit tests for new functionality
- Include integration tests for complex features

### Linting and Formatting
- Pre-commit hooks are configured (`.pre-commit-config.yaml`)
- Use pylint for Python code quality
- Follow existing code formatting patterns
- Run `pre-commit run --all-files` before committing

### Dependencies
- Manage dependencies in `pyproject.toml`
- Use dependency groups for different environments (dev, test, docs, etc.)
- Keep dependencies up to date with security considerations

## Weblate-Specific Patterns

### Internationalization (i18n)
- All user-facing strings must be translatable
- Use `gettext_lazy` for model fields and forms
- Use `{% translate %}` in templates
- Maintain plural forms correctly
- Consider RTL language support

### Version Control Integration
- Understand VCS abstraction layer in `weblate/vcs/`
- Support for Git, Mercurial, Subversion
- Repository operations should be atomic and safe
- Handle merge conflicts gracefully

### Translation Formats
- Support multiple file formats (PO, XLIFF, JSON, etc.)
- Format handlers are in `weblate/formats/`
- Maintain format integrity during operations
- Handle encoding issues properly

### Security Considerations
- Sanitize all user inputs
- Use Django's built-in security features
- Be careful with file uploads and VCS operations
- Validate translation keys and values
- Consider injection attacks in translation content

## API and Integration

### REST API
- Django REST Framework patterns
- API versioning considerations
- Proper authentication and permissions
- Rate limiting awareness

### Webhooks and Automation
- GitHub, GitLab, Bitbucket integration
- Webhook security (signature verification)
- Asynchronous processing with Celery

## Documentation

### Code Documentation
- Use docstrings for all public methods
- Include type hints where beneficial  
- Document complex algorithms and business logic
- Reference Django and Weblate documentation

### User Documentation
- Update docs in `docs/` directory (reStructuredText)
- Follow existing documentation structure
- Include examples and use cases
- Consider translation workflow impact

## Common Patterns to Follow

### Models
```python
from django.db import models
from django.utils.translation import gettext_lazy

class MyModel(models.Model):
    name = models.CharField(max_length=100, verbose_name=gettext_lazy("Name"))
    
    class Meta:
        verbose_name = gettext_lazy("My Model")
```

### Views
```python
from django.contrib.auth.decorators import login_required
from weblate.utils.views import ComponentViewMixin

class MyComponentView(ComponentViewMixin, TemplateView):
    template_name = "my_template.html"
```

### Forms
```python
from django import forms
from django.utils.translation import gettext_lazy

class MyForm(forms.Form):
    field = forms.CharField(label=gettext_lazy("Field"))
```

## File Organization

- Models: Define in appropriate app's `models.py`
- Views: Organize by functionality in `views.py` or view modules
- Forms: Keep in `forms.py` within relevant apps
- Templates: Store in `templates/` with app-specific subdirectories
- Static files: Organize in `static/` directories
- Tests: Place in `tests/` directories within apps

## Performance Considerations

- Use select_related() and prefetch_related() for database queries
- Cache expensive operations appropriately
- Consider memory usage with large translation files
- Optimize VCS operations for performance

## Contribution Guidelines

- Follow the existing code patterns and conventions
- Write tests for new features and bug fixes
- Update documentation when adding new features
- Consider backwards compatibility
- Be mindful of security implications
- Test with different VCS backends when relevant

## Resources

- [Weblate Documentation](https://docs.weblate.org/)
- [Django Documentation](https://docs.djangoproject.com/)
- [Contributing Guide](CONTRIBUTING.md)
- [Issue Tracker](https://github.com/WeblateOrg/weblate/issues)